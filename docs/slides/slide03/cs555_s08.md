---
lang: zh-CN
title: Cryptography - Pseudorandom Functions and CPA Security
description: 12-555-topic08
---

# (CS555) Pseudorandom Functions and CPA Security

## 本节大纲和阅读材料

### 本节大纲

- 键控函数(Keyed function)
- 伪随机函数(Pseudorandom function, abbr. PRF)
- 使用PRF进行加密
- 伪随机置换(Pseudorandom permutation, abbr. PRP)

### 阅读材料

- [Introduction to Modern Cryptography (3rd edition) - Katz and Lindell](https://www.cs.umd.edu/~jkatz/imc.html): 3.6.1 ~ 3.6.3

## 键控函数(Keyed function)

- 键控函数 $F: \{0, 1\}^k \times \{0, 1\}^{\star} \rightarrow \{0, 1\}^{\star}$
    - 需要两个输入，其中一个作为键/密钥(key)，第二个是寻常函数意义下的输入
    - 固定密钥 $k$，$F_k: \{0, 1\}^{\star} \rightarrow \{0, 1\}^{\star}$
    - 我们称 $F$ 是保长的，如果： $\lvert Fk(x)\rvert = \lvert x\rvert = \lvert k\rvert$ 
- 一个非正式的说法：一个键控函数 $F$ 是伪随机的，当且仅当：如果 $k \leftarrow\{0, 1\}^n$ 时，产生的函数与从所有 $\{0, 1\}^{\star} \rightarrow \{0, 1\}^{\star}$ 的函数中随机均匀选择的函数无法区分

### 使用 $Func_n$ —— 所有 $\{0, 1\}^{\star} \rightarrow \{0, 1\}^{\star}$ 的函数的集合

- 集合 $Func_n$ 的大小？
    - $(2^n)^{2^{n}} = 2^{n\cdot 2^{n}}$
        - 当 $n = 2$ 时，集合 $Func_n$ 的大小为 $28$ ；当 $n = 8$ 时，这个大小是 $22048$
- $Func_n$ 可以被视作一个巨大的查询表，该表为 $\{0, 1\}^n$ 中的每个字符串存储数值
    - 然后，该表可以被看作是一个长度为$n\cdot 2^n$的字符串
    - 我们可以定义一个键控函数，使得每个密钥选择 $Func_n$ 中的一个函数，将其称为随机函数
- 如何实现一个从 $Func_n$ 中随机选择的函数 $f$ ？
    - 维护一个最初为空的表。当人们查询 $f(x)$ 时，首先在表中查找，如果 $x$ 不存在，则随机选择 $y$ ，将 $(x, y)$ 添加到表中，并返回 $y$ ；如果 $(x, y)$ 存在，则返回 $y$ 。

### 随机函数的性质

- 设 $R$ 为随机函数，当 $k$ 被随机选择时，$R_k$ 给出 $Func_n$ 中的一个随机函数 
    - 对于 $a\neq b$，$R_k(a)$ 不能给出任何关于 $R_k(b)$ 的信息
- 如何使用随机函数 $R$ 进行加密？
    - 令 $Enc_k(m)=R_k(m)$ 如何？
- 正确的方法： 给定明文 $m$ ，随机地选择 $r$ ，然后计算 $c := \langle r, R_k(r)\oplus m\rangle$
    - 只要 $r$ 不重复，就不会泄露关于明文 $m$ 的信息
    - 假设一个充分长的随机字符串被共享，字符串中不同的部分用于加密不同的信息

## 伪随机函数(Pseudorandom function, abbr. PRF)

**[定义 2.3]**. 给定一个高效的(efficient)、保长的键控函数 $F: \{0, 1\}^k \times \{0, 1\}^{\star} \rightarrow \{0, 1\}^{\star}$，我们称 $F$ 是一个伪随机函数当且仅当对于所有的能力有限的区分器(PPT distinguisher) $D$，均存在一个可忽略的函数 $negl$ 使得

$$\lvert Pr[D^{Fk(\cdot)}(1^n) = 1] - Pr[D^{f(\cdot)}(1^n) = 1] \rvert \leq negl(n)$$

- 其中 $k \leftarrow\{0, 1\}^n$ 是均匀地随机选择的，$f$ 是从集合 $Func_n$ 中均匀地随机选择的
- $D$ 被赋予对一个函数的预言机访问/神谕访问(oracle access) ，通过预言机，$D$ 知道这个函数是一个随机的，还是来自 $F$ 的。

:::tip
**Q**: 在密码学中，PPT distinguisher $D$ 是什么意思？

**A**(*由AI生成*)：在密码学的语境下，“PPT”一词代表“概率多项式时间(Probabilistic Polynomial Time)”。它指的是在多项式时间内运行的算法或图灵机，其中有随机化成分(randomization component)。概率多项式时间算法(PPT算法)是概率性的，因为它们在计算过程中可以使用随机性。

“区分器(distinguisher)”是一种算法或攻击者，旨在区分不同的加密对象或属性。在PPT区分器的情况下，它们被用来区分加密方案或基元，如加密算法或哈希函数。

PPT区分器 $D$ 通常表示一种特定的区分器算法，它在概率多项式时间内运行。这种区分器的目的是分析一个加密方案或基元，确定它是否拥有某些理想的属性或安全保证。例如，在对称密钥密码学领域，可以采用PPT区分器来确定一个加密算法是否表现出强大的伪随机性或是否容易受到某些攻击。

值得注意的是，PPT区分器的具体功能和目标可能会因环境和被分析的加密原件而有所不同。
:::

:::tip
**Q**: 在密码学中，Oracle access是什么意思？

**A**(*由AI生成*)：在密码学和计算复杂性的语境下，“预言机访问”/“神谕访问”(Oracle access)指的是一种允许算法向神谕(Oracle)进行查询的理论构造。神谕是一个抽象的实体，代表一个黑盒子或一个能够进行特定计算的子程序。

预言机访问/神谕访问经常被用来模拟这样的场景：一个算法可以获得超出其自身计算能力的专业知识或能力。算法可以对预言机/神谕进行查询，提供输入，并接收相应的输出。预言机/神谕的行为通常是事先定义的，并不是算法内部工作的一部分。

预言机访问/神谕访问的目的是为了研究问题和算法的计算复杂性。通过允许算法与预言机/神谕互动，研究人员可以探索额外的信息或计算能力对算法的性能和效率的影响。

值得注意的是，在实践中，预言机访问/神谕访问是一个用于分析和理解的理论概念，而不是一个具体的实现。它有助于研究算法在各种计算场景中的极限和可能性。

:::tip
神谕访问这个词听起来比较中二，我喜欢这个翻译:cowboy_hat_face:
:::

:::

## 使用伪随机函数PRF的加密方案

- **[构造3.24]**. 使用一个伪随机函数 $F$：
    - 加密函数 $Enc_k(m): c := \langle r, F_k(r)\oplus m\rangle$
        - 其中，$r\leftarrow \{0, 1\}^n$ 是均匀地随机选取的，$\leftarrow$ 为采样符号，意为从某一集合中采样出某个样本
    - $Dec_k(c)$：在已知 $c = \langle r, s\rangle$ 的条件下，明文 $m := F_k(r)\oplus s$
    - 从直观上看，这是安全的：只要相同的 $r$ 不要用于加密不同的明文，函数 $F_k(r)$ 就是“看上去完全随机的”，因此 $m$ 就像是被一次性密码本加密了一样。
- **[定理 3.25]**. 如果函数 $F$ 是伪随机函数，那么**[构造3.24]**就是CPA安全的。

### 定理3.25的证明

- 对于任何能够打破 $\Pi$ (**构造3.24**)的CPA安全的攻击 $A$，构造一个区分器 $D$ 如下：
    - $D$ 被赋予对函数 $g$ 的预言机访问，并能够从中知道 $g$ 是从哪个分布中提取的。
    - 当攻击者 $A$ 请求一次加密，使用由此式定义的加密算法：$c := \langle r, g(r)\oplus m\rangle$
    - 如果攻击者 $A$ 在猜测 $m_0$ 和 $m_1$ 之中哪个明文被挑战者使用上面的算法加密了，输出$1$ (代表PRF), 否则输出 $0$ (代表Random)
- 当给定 $D$ 一个随机函数 $f$
    - $Pr[D^{f(\cdot)}(1^n) = 1] = Pr[PrivK^{cpa}_{A, \Lambda} = 1] \leq \frac{1}{2} + \frac{q(n)}{2^n}$
    - 假设攻击者 $A$ 发送至多 $q(n)$ 次加密的请求
    - 我们使用$\Lambda$ 表征利用了随机函数的 **构造 3.24**
    - 挑战者的明文加密用的 $r$ 没有被用于其他明文的加密中时，有 $Pr[PrivK^{cpa}_{A, \Lambda} = 1] = \frac{1}{2}$
    - 在其他挑战中出现 $r$ 的可能性是 $\frac{q(n)}{2^n}$
- 当给定 $D$ 一个伪随机函数
    - $Pr[D^{Fk(\cdot)}(1^n) = 1] = Pr[PrivK^{cpa}_{A, \Pi} = 1]$
- 因此
    - $Pr[PrivK^{cpa}_{A, \Pi} = 1] \ge \frac{1}{2} + negl(n)$ 当且仅当 $\lvert Pr[D^{Fk(\cdot)}(1^n) = 1] - Pr[D^{f(\cdot)}(1^n) = 1] \rvert \ge negl(n)$

:::tip
**Q**: 在密码学中，如何理解表达式 $Pr[PrivK^{cpa}_{A, \Pi} = 1]$？

**A**(*由AI生成*)：在密码学中，表达式 $Pr[PrivK^{cpa}_{A, \Pi} = 1]$ 通常表示攻击者 $A$ 在获得挑战者的加密神谕访问时，正确猜出或区分对明文的加密的概率。

我们来分解一下这个表达式：

- $PrivK^{cpa}_{A, \Pi}$ 是指在选择明文攻击安全(CPA-Secure)方面的一个安全实验。该实验涉及一个攻击者 $A$ 和一个加密方案或基元 $\Pi$ 。实验的目的是评估攻击者区分明文加密的能力。
    - 其中，$PrivK$ 指私钥(Private-Key)，它是一个前缀，通常用于表示安全实验或游戏，评估私钥密码方案或基元的安全性。$PrivK$ 前缀后面通常有其他字母或上下标，以指定被评估的特定安全类型。例如：
        - $PrivK^{eav}$ 指的是一种被称为“针对窃听者的加密”游戏的安全实验。它测试攻击者通过观察密码文本获得明文信息的能力。
        - $PrivK^{cca}$ 指的是一个被称为“选择密码文本攻击”游戏的安全实验。它考察了一个方案的安全性，以对抗拥有加密神谕访问的对手，该对手能进行查询并收到解密响应。
- $Pr[\ldots]$ 表示方括号内的事件的概率。在这种情况下，它表示攻击者成功区分对明文的加密的事件的概率。
- 方括号内的 $= 1$ 标志着实验的成功结果或事件。它意味着攻击者 $A$ 以 $1$ 的概率，正确地区分了对明文的加密。

总的来说，表达式 $Pr[PrivK^{cpa}_{A, \Pi} = 1]$ 被用于量化攻击者 $A$ 在选择明文攻击安全实验中的成功概率。它衡量了对手区分加密的能力，并提供了对所分析的加密方案 $\Pi$ 的安全性或不可区分性的一个量化。
:::

## 伪随机置换(Pseudorandom permutation, abbr. PRP)

- 我们称保长的键控函数 $F: \{0, 1\}^k \times \{0, 1\}^{\star} \rightarrow \{0, 1\}^{\star}$是一个键控置换(keyed permutation)当且仅当每一个 $F_k$ 都是双射(bijection)。
- 一个伪随机置换是指一个与随机置换(random permutation)无法区分的键控置换。
- 一个强的伪随机置换是指当区分者被赋予了对该函数和其反函数的访问权时，与一个随机置换无法区分的监控置换。
- 我们认为分组密码(block cipher)是伪随机变换。
