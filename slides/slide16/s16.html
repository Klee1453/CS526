<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.62">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Analysis of DAC's Weaknesses | 名字还没想好</title><meta name="description" content="14-526-topic16">
    <link rel="preload" href="/CS526/assets/style-ba7c0503.css" as="style"><link rel="stylesheet" href="/CS526/assets/style-ba7c0503.css">
    <link rel="modulepreload" href="/CS526/assets/app-eef777f9.js"><link rel="modulepreload" href="/CS526/assets/s16.html-79243d05.js"><link rel="modulepreload" href="/CS526/assets/f11_udacr2-226cb55f.js"><link rel="modulepreload" href="/CS526/assets/s16.html-3e4683e1.js"><link rel="prefetch" href="/CS526/assets/index.html-bb88a072.js" as="script"><link rel="prefetch" href="/CS526/assets/index.html-263979f5.js" as="script"><link rel="prefetch" href="/CS526/assets/s00.html-f2fe8234.js" as="script"><link rel="prefetch" href="/CS526/assets/cs555_s08.html-ea0f08fe.js" as="script"><link rel="prefetch" href="/CS526/assets/s03.html-2725b481.js" as="script"><link rel="prefetch" href="/CS526/assets/s07.html-5709aebb.js" as="script"><link rel="prefetch" href="/CS526/assets/s08.html-d06157a0.js" as="script"><link rel="prefetch" href="/CS526/assets/s19.html-6b1675b3.js" as="script"><link rel="prefetch" href="/CS526/assets/s22.html-58f87baa.js" as="script"><link rel="prefetch" href="/CS526/assets/cs555_s08.html-fc1f5a8b.js" as="script"><link rel="prefetch" href="/CS526/assets/s03.html-02c3c298.js" as="script"><link rel="prefetch" href="/CS526/assets/s07.html-fa677287.js" as="script"><link rel="prefetch" href="/CS526/assets/s08.html-dedd5f46.js" as="script"><link rel="prefetch" href="/CS526/assets/s16.html-4962359e.js" as="script"><link rel="prefetch" href="/CS526/assets/s19.html-c8125827.js" as="script"><link rel="prefetch" href="/CS526/assets/s22.html-05dc9717.js" as="script"><link rel="prefetch" href="/CS526/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/CS526/assets/index.html-0cc8bf91.js" as="script"><link rel="prefetch" href="/CS526/assets/index.html-663e02ca.js" as="script"><link rel="prefetch" href="/CS526/assets/s00.html-06c4b2bb.js" as="script"><link rel="prefetch" href="/CS526/assets/cs555_s08.html-efeb0aed.js" as="script"><link rel="prefetch" href="/CS526/assets/s03.html-6b3b0df0.js" as="script"><link rel="prefetch" href="/CS526/assets/s07.html-831636f8.js" as="script"><link rel="prefetch" href="/CS526/assets/s08.html-7a2d519c.js" as="script"><link rel="prefetch" href="/CS526/assets/s19.html-6318efa3.js" as="script"><link rel="prefetch" href="/CS526/assets/s22.html-796659e1.js" as="script"><link rel="prefetch" href="/CS526/assets/cs555_s08.html-37c4749e.js" as="script"><link rel="prefetch" href="/CS526/assets/s03.html-f6e64eb9.js" as="script"><link rel="prefetch" href="/CS526/assets/s07.html-a5132cde.js" as="script"><link rel="prefetch" href="/CS526/assets/s08.html-eb224c95.js" as="script"><link rel="prefetch" href="/CS526/assets/s16.html-eb9fb1e5.js" as="script"><link rel="prefetch" href="/CS526/assets/s19.html-64725302.js" as="script"><link rel="prefetch" href="/CS526/assets/s22.html-6a761ce3.js" as="script"><link rel="prefetch" href="/CS526/assets/404.html-ee623422.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/CS526/" class=""><img class="logo" src="/CS526/images/logo.png" alt="名字还没想好"><span class="site-name can-hide">名字还没想好</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/CS526/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/Klee1453/CS526" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.cs.purdue.edu/homes/ninghui/courses/526_Fall14/lectures.html" rel="noopener noreferrer" target="_blank" aria-label="CS526 - PU"><!--[--><!--]--> CS526 - PU <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/CS526/slides/slide16/s16.html" class="router-link-active router-link-exact-active router-link-active" aria-label="zh-CN"><!--[--><!--]--> zh-CN <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/CS526/en/slides/slide16/s16.html" class="" aria-label="en-US"><!--[--><!--]--> en-US <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/CS526/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/Klee1453/CS526" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.cs.purdue.edu/homes/ninghui/courses/526_Fall14/lectures.html" rel="noopener noreferrer" target="_blank" aria-label="CS526 - PU"><!--[--><!--]--> CS526 - PU <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/CS526/slides/slide16/s16.html" class="router-link-active router-link-exact-active router-link-active" aria-label="zh-CN"><!--[--><!--]--> zh-CN <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/CS526/en/slides/slide16/s16.html" class="" aria-label="en-US"><!--[--><!--]--> en-US <!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">CS526 <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">Topic03: Cryptography - One-time Pad, Information Theoretic Security, and Stream Ciphers <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/CS526/slides/slide03/s03.html" class="sidebar-item" aria-label="Cryptography - One-time Pad, Information Theoretic Security, and Stream Ciphers"><!--[--><!--]--> Cryptography - One-time Pad, Information Theoretic Security, and Stream Ciphers <!--[--><!--]--></a><!----></li><li><a href="/CS526/slides/slide03/cs555_s08.html" class="sidebar-item" aria-label="Cryptography - Pseudorandom Functions and CPA Security"><!--[--><!--]--> Cryptography - Pseudorandom Functions and CPA Security <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">Topic07: User Authentication <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/CS526/slides/slide07/s07.html" class="sidebar-item" aria-label="User Authentication"><!--[--><!--]--> User Authentication <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">Topic08: Operating Systems Security Basics &amp; Unix Access Control <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/CS526/slides/slide08/s08.html" class="sidebar-item" aria-label="Unix Access Control"><!--[--><!--]--> Unix Access Control <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item active collapsible">Topic16: Analysis of DAC&#39;s Weaknesses <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/CS526/slides/slide16/s16.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Analysis of DAC&#39;s Weaknesses"><!--[--><!--]--> Analysis of DAC&#39;s Weaknesses <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#参考资料" class="router-link-active router-link-exact-active sidebar-item" aria-label="参考资料"><!--[--><!--]--> 参考资料 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#为什么计算机是易受攻击的-vulnerable" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么计算机是易受攻击的(Vulnerable)?"><!--[--><!--]--> 为什么计算机是易受攻击的(Vulnerable)? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#访问控制检查" class="router-link-active router-link-exact-active sidebar-item" aria-label="访问控制检查"><!--[--><!--]--> 访问控制检查 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#自主访问控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="自主访问控制"><!--[--><!--]--> 自主访问控制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#关于dac缺陷的分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于DAC缺陷的分析"><!--[--><!--]--> 关于DAC缺陷的分析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#困惑的副手问题-the-confused-deputy-problem" class="router-link-active router-link-exact-active sidebar-item" aria-label="“困惑的副手问题”(The Confused Deputy problem)"><!--[--><!--]--> “困惑的副手问题”(The Confused Deputy problem) <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#关于-困惑的副手问题-的分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于“困惑的副手问题”的分析"><!--[--><!--]--> 关于“困惑的副手问题”的分析 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#访问控制矩阵模型-access-matrix-model" class="router-link-active router-link-exact-active sidebar-item" aria-label="访问控制矩阵模型 (Access matrix model)"><!--[--><!--]--> 访问控制矩阵模型 (Access matrix model) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#访问控制矩阵模型的实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="访问控制矩阵模型的实现"><!--[--><!--]--> 访问控制矩阵模型的实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#权能-capabilities-的不同概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="权能（Capabilities）的不同概念"><!--[--><!--]--> 权能（Capabilities）的不同概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#更多关于基于权能的访问控制" class="router-link-active router-link-exact-active sidebar-item" aria-label="更多关于基于权能的访问控制"><!--[--><!--]--> 更多关于基于权能的访问控制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#使用权能的概念如何解决-困惑的副手问题" class="router-link-active router-link-exact-active sidebar-item" aria-label="使用权能的概念如何解决“困惑的副手问题”"><!--[--><!--]--> 使用权能的概念如何解决“困惑的副手问题” <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#权能与访问控制列表的对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="权能与访问控制列表的对比"><!--[--><!--]--> 权能与访问控制列表的对比 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#权能与访问控制列表的对比-环境权限-ambient-authority" class="router-link-active router-link-exact-active sidebar-item" aria-label="权能与访问控制列表的对比: 环境权限(Ambient Authority)"><!--[--><!--]--> 权能与访问控制列表的对比: 环境权限(Ambient Authority) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#权能与访问控制列表的对比-命名-naming" class="router-link-active router-link-exact-active sidebar-item" aria-label="权能与访问控制列表的对比: 命名(Naming)"><!--[--><!--]--> 权能与访问控制列表的对比: 命名(Naming) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#关于为什么大多数的现实世界操作系统采用acl而不是capabilities的推测" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于为什么大多数的现实世界操作系统采用ACL而不是Capabilities的推测"><!--[--><!--]--> 关于为什么大多数的现实世界操作系统采用ACL而不是Capabilities的推测 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#dac-的固有弱点" class="router-link-active router-link-exact-active sidebar-item" aria-label="DAC 的固有弱点"><!--[--><!--]--> DAC 的固有弱点 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#一个木马程序的例子" class="router-link-active router-link-exact-active sidebar-item" aria-label="一个木马程序的例子"><!--[--><!--]--> 一个木马程序的例子 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#有漏洞的软件可能成为木马程序" class="router-link-active router-link-exact-active sidebar-item" aria-label="有漏洞的软件可能成为木马程序"><!--[--><!--]--> 有漏洞的软件可能成为木马程序 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#dac的弱点是由于主体与权限持有者之间存在差距所致" class="router-link-active router-link-exact-active sidebar-item" aria-label="DAC的弱点是由于主体与权限持有者之间存在差距所致"><!--[--><!--]--> DAC的弱点是由于主体与权限持有者之间存在差距所致 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#unix-dac-revisited-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="Unix DAC Revisited (1)"><!--[--><!--]--> Unix DAC Revisited (1) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#对unix系统中dac的重新审视-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="对Unix系统中DAC的重新审视(1)"><!--[--><!--]--> 对Unix系统中DAC的重新审视(1) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#对unix系统中dac的重新审视-2" class="router-link-active router-link-exact-active sidebar-item" aria-label="对Unix系统中DAC的重新审视(2)"><!--[--><!--]--> 对Unix系统中DAC的重新审视(2) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/CS526/slides/slide16/s16.html#为什么dac是易受攻击的" class="router-link-active router-link-exact-active sidebar-item" aria-label="为什么DAC是易受攻击的？"><!--[--><!--]--> 为什么DAC是易受攻击的？ <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">Topic 19: Integrity Protection Models <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/CS526/slides/slide19/s19.html" class="sidebar-item" aria-label="Integrity Protection Models"><!--[--><!--]--> Integrity Protection Models <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">Topic 22: Role and Attribute Based Access Control <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/CS526/slides/slide22/s22.html" class="sidebar-item" aria-label="Role and Attribute Based Access Control"><!--[--><!--]--> Role and Attribute Based Access Control <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="关于自主访问控制-discretionary-access-control-abbr-dac-的分析" tabindex="-1"><a class="header-anchor" href="#关于自主访问控制-discretionary-access-control-abbr-dac-的分析" aria-hidden="true">#</a> 关于自主访问控制(Discretionary Access Control, abbr. DAC)的分析</h1><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Discretionary_access_control" target="_blank" rel="noopener noreferrer">自主访问控制 - 维基百科(英文)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h2 id="为什么计算机是易受攻击的-vulnerable" tabindex="-1"><a class="header-anchor" href="#为什么计算机是易受攻击的-vulnerable" aria-hidden="true">#</a> 为什么计算机是易受攻击的(Vulnerable)?</h2><ul><li>计算机程序往往充满了Bug</li><li>人类程序员会犯错</li><li>访问控制做的不够好 <ul><li>在Unix和Windows系统中使用的自主访问控制(Discretionary Access Control, abbr. DAC)假定所有程序不存在Bug</li></ul></li></ul><h2 id="访问控制检查" tabindex="-1"><a class="header-anchor" href="#访问控制检查" aria-hidden="true">#</a> 访问控制检查</h2><ul><li>给出一个访问请求，返回一个基于策略(policy)的访问控制决定 <ul><li>返回允许或者拒绝</li></ul></li></ul><p><img src="/CS526/assets/f01_acc-98b175c9.png" alt="ACC"></p><h2 id="自主访问控制" tabindex="-1"><a class="header-anchor" href="#自主访问控制" aria-hidden="true">#</a> 自主访问控制</h2><ul><li><p>自主访问控制这一概念没有精确的定义。 其基本概念是，DAC允许主体自行传播访问权限。</p><ul><li>通常有一个对象的所有者的概念</li><li>在UNIX、Windows等系统中使用。</li></ul></li><li><p>根据可信的计算机系统评估标准(Trusted Computer System Evaluation Criteria, abbr. TCSEC)的规定:</p><ul><li>它是根据主体（如用户、进程或 I/O 设备等）的身份和主体所属的组，来限制对对象的访问的方法。对访问权限的控制是自主的，即拥有某项访问权限的主体可以将该权限（直接或间接地）传递给任何其他主体。</li></ul></li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>所谓的自主（Discretionary，拥有自由裁量权的），是因为拥有访问权限的主体，可以直接（或间接）地将访问权限赋予其他主体（除非受到强制访问控制的限制）。</p><p>所有者有权自行进一步分享。</p></div><details class="custom-container details"><p><strong>Q</strong>: 什么是自主访问控制？</p><p><strong>A</strong>(<em>AI生成</em>):</p><p>自主访问控制（Discretionary Access Control，DAC）是计算机系统中使用的一种安全模型，根据资源所有者的自主权来调控对资源的访问。在DAC中，资源所有者有权决定谁能够访问其资源以及所拥有的访问级别。</p><p>在自主访问控制系统中，每个资源（如文件、文件夹或设备）都与一个访问控制列表（Access Control List，ACL）相关联，该列表规定了不同用户或组的权限或访问权。访问控制列表通常包含用户或组及其相应权限的列表，如读取、写入、执行或删除等。</p><p>自主访问控制的关键特点包括：</p><p>资源所有者自主权：资源所有者有权决定谁能够访问资源以及所拥有的访问级别。所有者可以修改访问控制列表，根据需要授予或撤销访问权限。</p><p>个别用户权限：为每个用户或组分配特定的资源访问权限。这些权限确定用户对资源可以执行的操作，如读取、修改或删除等。</p><p>访问控制列表：使用访问控制列表来定义和管理资源的权限。访问控制列表包含用户或组的条目以及其关联的权限。</p><p>简单灵活：DAC是一种简单的访问控制模型，易于理解和实现。它通过允许资源所有者对访问权限进行细粒度控制来提供灵活性。</p><p>自主访问控制的一个限制是它仅依赖于资源所有者的自主权，有时可能导致不一致或不适当的访问决策。其他访问控制模型，如强制访问控制（Mandatory Access Control，MAC）和基于角色的访问控制（Role-Based Access Control，RBAC），旨在通过提供更严格和更标准化的访问控制机制来解决这些限制。</p><details class="custom-container details"><p>强制访问控制（MAC）： 强制访问控制是一种更严格的访问控制模型，与自主访问控制相比，它将访问控制的决策从资源所有者转移到了系统管理员或安全策略制定者。在MAC中，每个资源和主体（用户或进程）都被赋予一个安全级别或标签，这些级别基于安全策略和需求进行定义。资源的访问权限由系统根据其安全级别和主体的安全级别进行强制执行，而不是由资源所有者自主决定。这种模型可以实现更严格的访问控制，以确保资源的保密性和完整性。</p><p>基于角色的访问控制（RBAC）： 基于角色的访问控制是一种将权限分配与用户角色相关联的访问控制模型。在RBAC中，用户被分配到不同的角色，而角色则与特定的权限集相关联。用户通过担任特定角色来获得与该角色关联的权限。这种模型使得访问控制管理更加集中化和易于管理。相比自主访问控制，RBAC提供了更标准化和可扩展的访问控制机制，并且可以更容易地适应组织的变化和复杂性。</p><details class="custom-container details"><p>基于角色的访问控制相比自主访问控制提供了更加标准化和可扩展的访问控制机制。以下是原因：</p><p>标准化：RBAC通过将权限与预定义角色相关联，引入了一种结构化的访问控制方法。角色代表组织内的工作职能或责任。这种标准化使得访问控制策略的管理和维护更加容易。不再需要为每个用户分配权限，而是将权限分配给角色，并根据用户的工作要求将其分配到适当的角色中。这简化了访问控制的管理，并确保组织内的一致性。</p><p>可扩展性：RBAC非常适合具有复杂访问控制需求的大型组织或系统。随着组织的发展或变化，可以定义或修改新角色以适应不断变化的访问需求。添加或删除用户变得更加简化，因为他们的访问权限取决于其角色成员资格。这种可扩展性使得RBAC能够适应组织的动态变化和规模，而不会影响安全性或需要大量的行政开销。</p><p>职责分离：RBAC允许职责的分离，这对于减轻未经授权的活动或欺诈风险至关重要。通过为不同的个体分配具有特定权限的不同角色，RBAC确保没有单个用户拥有过多的特权或对关键操作拥有完全控制。这种分离有助于执行安全策略，并最大程度地减少滥用或未经授权访问的可能性。</p></details></details></details><h2 id="关于dac缺陷的分析" tabindex="-1"><a class="header-anchor" href="#关于dac缺陷的分析" aria-hidden="true">#</a> 关于DAC缺陷的分析</h2><ul><li>DAC 导致“困惑的副手问题”(Confused Deputy problem) <ul><li>解决方案：使用基于权能的(capability-based)访问控制系统</li></ul></li><li>DAC 在面对木马时无法保持机密性 <ul><li>解决方案：使用强制访问控制（Bell-LaPadula模型，在这个模型中，用户不能下写、不能上读）</li></ul></li><li>DAC 实施未能跟踪一个主体（进程）代表哪些授权主体(principal)执行操作 <ul><li>解决方案：改进 DAC 的实现以更好地跟踪授权主体</li></ul></li></ul><details class="custom-container details"><p>困惑的副手问题：DAC 可能导致困惑的副手问题，即拥有特定访问权限的主体可能会被欺骗或操纵，代表另一个实体执行其不应该访问的操作。这会带来安全风险，因为主体超出了其预期权限。解决这个问题的方法是使用基于权能的系统，在此系统中，访问是基于特定权能或令牌授予的，而不仅仅依赖于主体的权限。</p><p>木马病毒下的机密性缺失：DAC 在面对木马病毒或恶意代码时无法有效解决机密性问题。如果拥有访问权限的主体受到木马病毒的侵害，恶意代码可以利用主体的权限，未经授权地访问敏感数据。为了降低这种风险，可以实施强制访问控制（MAC）系统，如贝尔-拉帕杜拉模型（BLP）。MAC 根据安全标签强制执行严格的访问控制，防止信息从较高安全级别流向较低安全级别，从而保护机密性。</p><p>执行授权主体的跟踪不足：DAC 实施通常无法跟踪一个主体（进程）代表哪些授权主体执行操作。这种缺乏问责和审计可能导致难以识别和追踪行动的责任方。为了解决这个问题，关键是改进 DAC 实施，更好地跟踪和记录与每个主体行动相关的授权主体。这增强了问责权能，并有助于在发生安全事件或违反政策时进行调查。</p></details><h2 id="困惑的副手问题-the-confused-deputy-problem" tabindex="-1"><a class="header-anchor" href="#困惑的副手问题-the-confused-deputy-problem" aria-hidden="true">#</a> “困惑的副手问题”(The Confused Deputy problem)</h2><p><img src="/CS526/assets/f02_cdp-63ecd33c.png" alt="cdp"></p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>编译器程序是<code>SYSX/FORT</code>。</p><p><code>SYSX</code>目录下的其他文件包括<code>STAT</code>和<code>BILL</code>。</p><p>编译器程序需要向<code>SYSX</code>目录中的文件写入数据，因此它被授予在<code>SYSX</code>中写入文件的权限。 运行<code>SYSX/FORT</code>的用户可以提供一个文件名来接收输出信息。</p><p>恶意用户可能会将<code>SYSX/BILL</code>作为输出文件名，导致<code>BILL</code>文件中原先的内容被删除。</p></div><h3 id="关于-困惑的副手问题-的分析" tabindex="-1"><a class="header-anchor" href="#关于-困惑的副手问题-的分析" aria-hidden="true">#</a> 关于“困惑的副手问题”的分析</h3><ul><li>编译器从两个源头获取权限 <ul><li>调用者（即程序员）</li><li>系统管理员（安装编译器并控制计费(向<code>SYSX/BILL</code>文件写入账单)和其他信息）</li></ul></li><li>编译器是两个主体的副手</li><li>在执行写操作时，无法确定副手是为哪个主体提供服务</li><li>解决方案：使用使用基于权能的(capability-based)访问控制系统</li></ul><details class="custom-container details"><p>对于“编译器是两个主体的副手”这一表述，它指的是编译器具有的双重权限或控制。编译器从两个不同的来源获得权限：调用者（程序员）和系统管理员。</p><p>作为“副手”，编译器代表两个主体行事，即根据程序员和系统管理员的委派执行任务和操作。程序员依赖编译器将其代码解释和转换为可执行指令，而系统管理员则安装了编译器并管理与系统相关的方面，如计费和其他信息，对编译器的安装和使用拥有控制权。</p><p>然而，这也意味着编译器在决策或优先级方面不偏向任何一方。它以中立和公正的方式行事，不对程序员或系统管理员偏袒，执行其功能而不带有任何偏见。</p><p>“在执行写操作时，无法确定副手是为哪个主体提供服务”表明，在进行写操作时，不可能确定或归因于编译器的行动是程序员还是系统管理员的独立影响。这种不明确性可能导致在写操作时出现所有权或责任方面的混淆或模糊。</p><p>提出的解决方案是使用基于权能的访问控制系统，通过使用基于权能的访问控制，可以更精确地定义和归属于特定来源的编译器的权限和授权，确保对其行为的明确性和控制。</p><p>在这个有关编译器的例子中，使用基于权能的访问控制意味着实施一个访问控制系统，它向编译器授予特定的权限或权能。这些权能定义了编译器被允许执行的操作，并与特定的来源或实体（如程序员或系统管理员）相关联。</p><p>不再仅依赖于程序员和系统管理员授予的一般权限，编译器将具有明确的权能来确定其访问和权限。这些权能可以细粒度地指定编译器被允许执行的操作或行为。</p><p>例如，程序员授予编译器的权能可能包括读取和编译源代码文件、优化代码和生成可执行文件的权能。而系统管理员授予的权能可能包括访问系统资源、使用特定库或API以及执行必要的计费操作的权能。</p><p>通过使用基于权能的访问控制，授予编译器的权限和许可变得更加精确地定义和归属于特定的来源。这确保了对编译器行为的明确性和控制，因为每个权能与特定的功能或任务相关联。</p><p>在实际操作中，基于权能的访问控制可以涉及实施一个系统，为编译器分配特定的令牌或权限，使其能够访问特定资源或执行特定操作。这些令牌可以由底层系统验证和执行，确保编译器仅具有经过授权的权能，并且不能超出其定义的边界。这种方法提供了一种更精确和受控的方式来确定编译器的访问和权限，增强安全性并减少模糊性。</p></details><div class="custom-container tip"><p class="custom-container-title">TIP</p><p><strong>Q</strong>: “困惑的副手问题”是如何在UNIX访问控制系统中被解决的? <strong>A</strong>(<em>由AI生成</em>)：</p><p>在UNIX访问控制系统中，通过最小权限原则（Principle of Least Privilege）和权限分离（Separation of Privileges）来缓解这个问题。</p><p>在UNIX中，该问题通过同时实施自主访问控制（DAC）和强制访问控制（MAC）机制来解决。</p><ul><li>自主访问控制（DAC）：UNIX使用DAC作为主要的访问控制机制。DAC允许资源所有者确定其资源的访问权限。通过使用<code>chmod</code>命令设置适当的文件权限（例如，对所有者、组和其他用户的读取、写入、执行权限），资源所有者可以限制对其文件的访问。 <ul><li>最小权限原则：最小权限原则是一个基本的安全原则，将访问权限限制在实现特定任务所需的权限范围内。在UNIX中，程序通常以调用它们的用户的权限而不是提升的权限来执行。这有助于防止程序执行超出其预期功能范围的操作。</li><li>权限分离：UNIX采用模块化设计，不同的组件具有单独的权限，并在隔离的环境中运行。例如，需要提升权限的系统进程（如管理网络连接或配置系统设置）以较高的权限（例如，root或管理员访问权限）执行。常规用户程序以启动它们的用户的权限执行，提供一定程度的隔离并限制其潜在影响。</li></ul></li></ul><p>通过结合DAC、最小权限原则和权限分离，UNIX访问控制系统减轻了困惑的副手问题带来的影响。资源所有者可以定义访问权限，程序以受限权限执行，确保它们只能执行资源所有者允许的操作，并防止执行未经授权的操作或访问敏感系统资源。</p></div><h3 id="访问控制矩阵模型-access-matrix-model" tabindex="-1"><a class="header-anchor" href="#访问控制矩阵模型-access-matrix-model" aria-hidden="true">#</a> 访问控制矩阵模型 (Access matrix model)</h3><p><img src="/CS526/assets/f03_amm-746c410a.png" alt="amm"></p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>这张图复习了有关<a href="/CS526/slides/slide08/s08.html" class="">访问控制矩阵模型</a>的概念.</p></div><h3 id="访问控制矩阵模型的实现" tabindex="-1"><a class="header-anchor" href="#访问控制矩阵模型的实现" aria-hidden="true">#</a> 访问控制矩阵模型的实现</h3><ul><li>访问控制列表(Access Control Lists) <ul><li>编码矩阵中的列</li></ul></li><li>权能(Capabilities) <ul><li>编码矩阵中的行</li></ul></li><li>访问控制三元组(Access control triples) <ul><li>编码矩阵中的每一个元胞</li></ul></li></ul><h4 id="访问控制列表-access-control-lists-abbr-acls" tabindex="-1"><a class="header-anchor" href="#访问控制列表-access-control-lists-abbr-acls" aria-hidden="true">#</a> 访问控制列表(Access Control Lists, abbr. ACLs)</h4><p><img src="/CS526/assets/f04_acl-9a51fb42.png" alt="acl"></p><ul><li>访问控制矩阵中的每一个列被存储在与这一列相关的访问控制客体中</li></ul><h4 id="权能列表-capabilities" tabindex="-1"><a class="header-anchor" href="#权能列表-capabilities" aria-hidden="true">#</a> 权能列表(Capabilities)</h4><p><img src="/CS526/assets/f05_cl-cb9f4b14.png" alt="cl"></p><ul><li>访问控制矩阵中的每一个行被存储在与这一行相关的访问控制主体中</li></ul><h4 id="访问控制三元组-access-control-triples" tabindex="-1"><a class="header-anchor" href="#访问控制三元组-access-control-triples" aria-hidden="true">#</a> 访问控制三元组(Access control triples)</h4><p><img src="/CS526/assets/f06_act-f1154e19.png" alt="act"></p><ul><li>在关系型数据库管理系统(relational DBMS)中常用的访问控制三元组用于指定和实施访问控制策略。</li></ul><details class="custom-container details"><p>在关系型数据库管理系统(relational DBMS)中常用的访问控制三元组用于指定和实施访问控制策略，访问控制三元组由三个元素组成：主体（Subject）、对象（Object）和权限（Permission）。这些元素定义了主体（用户或进程）、对象（数据或资源）以及主体对对象所允许的权限或操作之间的关系。</p><p>主体代表着正在寻求访问或执行操作的实体。它可以是个别用户、用户组或进程。对象表示被访问或受保护的资源或数据，例如表、文件或数据库中的特定记录。权限定义了主体对对象所授予的具体操作或权限，如读取、写入、更新或删除等。</p><p>通过定义访问控制三元组，管理员可以建立精细的访问控制策略，管理数据库中主体和对象之间的交互。这些三元组通常存储在访问控制矩阵或类似的数据结构中，以实现对访问控制规则的高效查找和执行。</p><p>当主体尝试在对象上执行操作时，访问控制机制会检查访问控制三元组，以确定主体是否具有所请求操作所需的权限。如果主体的访问权限与访问控制三元组中指定的权限匹配，操作将被允许进行。否则，访问将被拒绝，主体将被阻止执行所请求的操作。</p><p>访问控制三元组在关系型数据库管理系统中提供了一种灵活和可定制的访问控制方法。它们使管理员能够以细粒度管理访问权限，确保只有授权实体可以对受保护的资源执行特定操作。</p></details><h3 id="权能-capabilities-的不同概念" tabindex="-1"><a class="header-anchor" href="#权能-capabilities-的不同概念" aria-hidden="true">#</a> 权能（Capabilities）的不同概念</h3><ul><li>权能作为访问矩阵的行被表示</li><li>权能在Linux中的使用：将root权限分割成多个独立的、可以单独分配的部分</li><li>权能作为实现整个访问控制系统的一种方式 <ul><li>主体拥有权能，可以传递</li><li>当访问资源时，主体选择权能进行访问 <ul><li>一个例子是打开的文件描述符</li></ul></li><li>我们将更深入地研究这最后一个概念</li></ul></li></ul><h3 id="更多关于基于权能的访问控制" tabindex="-1"><a class="header-anchor" href="#更多关于基于权能的访问控制" aria-hidden="true">#</a> 更多关于基于权能的访问控制</h3><ul><li>主体拥有权能 <ul><li>给予它们对资源的访问权限 <ul><li>类似于钥匙</li></ul></li><li>权能是可转让和无法伪造的授权令牌 <ul><li>可以从一个进程传递给另一个进程 <ul><li>类似于已打开的文件描述符</li></ul></li></ul></li></ul></li><li>为什么权能可以解决困惑的副手问题？ <ul><li>当访问资源时，必须选择一个权能，这也选择了一个主体的权威</li></ul></li></ul><details class="custom-container details"><p>这个说法中的“类似于打开的文件描述符”指的是权能和打开的文件描述符在可转移性和使用方式上的相似性。在文本的语境中，权能被描述为可转移且不可伪造的权限令牌，可以在进程之间传递。这个概念与打开的文件描述符进行了比较，后者在某些操作系统中也可以在进程之间传递。</p><p>就像打开的文件描述符允许进程访问和操作特定的文件或资源一样，权能提供了一种进程或主体以受控方式访问和交互资源的手段。这种比较强调了权能和打开的文件描述符作为授予和管理资源访问的机制的共同特征，尽管在访问控制系统的背景下，权能是一个更广泛的概念。</p></details><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>例子：一个秘书为两位姓李的教职人员工作，但将一个人的账单记入另一个人的账户。</p><p>在访问控制列表（ACL）中，两位教职人员都授权秘书可以向他们的账户记账。这可能导致混淆。</p><p>在基于权能的系统中，秘书被授予记账的权利，这些权利以令牌的形式存在。当秘书处理其中一位教职人员的账单时，必须提供相应的权能令牌，以避免混淆。</p></div><h3 id="使用权能的概念如何解决-困惑的副手问题" tabindex="-1"><a class="header-anchor" href="#使用权能的概念如何解决-困惑的副手问题" aria-hidden="true">#</a> 使用权能的概念如何解决“困惑的副手问题”</h3><p><img src="/CS526/assets/f07_solve_cdp-4c83f721.png" alt="solve_cdp"></p><ul><li>调用者必须为<code>$OUTPUT</code>传入一个权能，它被存储在槽3中。</li><li>写入输出时使用槽3中的权能。</li><li>调用者不能传递一个它没有的权能。</li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>编译器程序被赋予访问<code>SYSX/STAT</code>和<code>SYSX/BILL</code>的权能，这些权能被存储在权能槽1和2中 当调用者运行编译器程序时，他提供了一个权能用于写入输出文件，该权能存储在权能槽3中。如果调用者没有<code>SYSX/BILL</code>的权能，就不能给它一个对应的权能。 当写计费信息（写入<code>SYSX/BILL</code>）时，程序使用槽2的权能。 当写输出时，程序使用槽3的权能。</p></div><h3 id="权能与访问控制列表的对比" tabindex="-1"><a class="header-anchor" href="#权能与访问控制列表的对比" aria-hidden="true">#</a> 权能与访问控制列表的对比</h3><ul><li>考虑两种银行账户的安全机制。</li><li>其中一种是基于身份的。每个账户有多个授权所有者。你去银行出示身份证明，然后可以访问您被授权的所有账户。 <ul><li>一旦出示身份证明，你可以访问所有账户。</li><li>你必须告诉银行从哪个账户取款。</li></ul></li><li>另一种是基于令牌的。当开设一个账户时，您会得到一个属于该账户的通行证和一个PIN码，只要持有通行证和PIN码的人可以访问账户。</li></ul><h3 id="权能与访问控制列表的对比-环境权限-ambient-authority" tabindex="-1"><a class="header-anchor" href="#权能与访问控制列表的对比-环境权限-ambient-authority" aria-hidden="true">#</a> 权能与访问控制列表的对比: 环境权限(Ambient Authority)</h3><ul><li>环境权限意味着用户的权限会自动被执行，无需进行选择。 <ul><li>这会导致困惑的副手问题。</li></ul></li><li>权能系统中没有环境权限。</li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>例如，你带了很多钥匙。当你走到一扇门前时，如果你有正确的钥匙，门会自动打开。你不需要选择一把钥匙。当你为多个主人工作时，这会引发问题。</p></div><h3 id="权能与访问控制列表的对比-命名-naming" tabindex="-1"><a class="header-anchor" href="#权能与访问控制列表的对比-命名-naming" aria-hidden="true">#</a> 权能与访问控制列表的对比: 命名(Naming)</h3><ul><li>基于ACL的访问控制系统需要为对象提供命名空间。</li><li>在基于权能的访问控制系统中，一个权能可以既用于指定资源，也用于提供权限。</li><li>基于ACL的访问控制系统还需要为主体或授权主体提供命名空间。 <ul><li>因为它们(这些系统)需要引用主体或授权主体。</li></ul></li><li>影响 <ul><li>主体的集合不能太多或过于动态。</li><li>大多数基于ACL的访问控制系统中，通常将权限或许可授予用户账户或授权主体。并不支持细粒度的主体权限管理。</li></ul></li></ul><details class="custom-container details"><p>在基于ACL的访问控制系统中，通常将权限或许可授予用户账户或授权主体。让我们来详细解释一下：</p><p>用户账户：在ACL系统中，用户被分配个别的用户账户。每个用户账户代表系统内的唯一身份，并与特定的权限和访问权限相关联。用户账户通常针对与系统进行交互的个别用户或实体而创建。</p><p>授权主体：ACL系统中的授权主体指被授予访问权限或权限的实体或主体。它们可以包括个别用户、组、角色或其他在系统中被认可和管理的实体。授权主体用于表示可以被分配或限制访问权限的实体。</p><p>在配置ACL系统中的访问控制时，权限或访问权限被授予这些用户账户或授权主体。这意味着特定的用户或实体会被明确分配某些权限，例如读取、写入、执行或管理权限，以执行系统内的特定资源或操作。</p><p>例如，在文件系统的ACL中，特定的用户或组可能会被授予某些文件的读取和写入权限，而其他用户只能具有只读访问权限。访问控制基于与系统相关联的用户账户或授权主体。</p><p>然而，需要注意的是，基于ACL的访问控制系统在细粒度授权主体权限管理方面可能存在一些限制。在某些ACL实现中，管理大量授权主体或动态更改授权主体集合可能变得复杂或具有挑战性。这就是基于权能的系统提供了另一种方法的地方，因为权能可以在管理访问权限和权限方面提供更大的灵活性和粒度。</p></details><h3 id="关于为什么大多数的现实世界操作系统采用acl而不是capabilities的推测" tabindex="-1"><a class="header-anchor" href="#关于为什么大多数的现实世界操作系统采用acl而不是capabilities的推测" aria-hidden="true">#</a> 关于为什么大多数的现实世界操作系统采用ACL而不是Capabilities的<strong>推测</strong></h3><ul><li>权能更适合进程级别的共享，而不是用户级别的共享 = 用户级别的共享才是真正所需的</li><li>在基于权能的系统中，进程之间更紧密地耦合，因为需要传递权能 <ul><li>编程可能更加困难</li></ul></li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>另一方面，当一个用户与另一个用户共享文件时，访问该文件的主体尚不存在。因此，需要存在一种命名方案。</p></div><h2 id="dac-的固有弱点" tabindex="-1"><a class="header-anchor" href="#dac-的固有弱点" aria-hidden="true">#</a> DAC 的固有弱点</h2><ul><li>无限制的 DAC 允许信息从一个可以被读取的对象流向任何一个可以被主体写入的对象 <ul><li>假设 A 被允许读取某些信息而 B 不被允许，A 可以读取并告诉 B</li></ul></li><li>即使我们相信用户不会故意这样做，但是木马程序仍然可以将信息从一个对象复制到另一个对象中。</li></ul><details class="custom-container details"><p>“未受限的自主访问控制（DAC）允许信息从一个可读对象流向任何一个被主体写入的对象”指的是自主访问控制系统中的一个漏洞或弱点。</p><p>在自主访问控制系统中，对象（如文件或资源）的访问权限由对象的所有者或创建者决定。所有者可以自行决定谁可以读取、写入或修改对象。然而，当自主访问控制在没有适当的限制或约束的情况下实施时，就可能导致意外的信息流动。</p><p>以下是一个例子来说明这个弱点：</p><p>对象A：包含着只有授权人员可以访问的敏感信息。 主体B：是一个具有读取对象A权限的用户或进程。</p><p>在未受限制的自主访问控制系统中，如果主体B被授予了读取对象A的权限，它有可能将对象A中的信息与任何其他它被授予写入权限的对象共享。这意味着主体B可以将对象A中的敏感信息复制或转移至另一个对象，而无论该对象是否打算存储相同级别的敏感信息或访问限制。</p><p>即使用户被认为不会故意滥用权限，这个漏洞仍然存在信息泄漏或意外信息流动的风险。它为未经授权的对象或实体通过合法途径获得敏感信息开启了可能性。</p><p>此外，自主访问控制系统中的这个弱点可以被恶意行为者或木马程序所利用。木马程序可以利用未受限制的自主访问控制权限在不被察觉的情况下将信息从一个对象复制或转移至另一个对象。这允许未经授权的提取或复制敏感数据，从而危及系统的安全性和完整性。</p><p>为了解决这个弱点，可以采取额外的访问控制机制，如强制访问控制（MAC）或更精细的控制，以限制信息流动并防止未经授权的数据泄漏。</p></details><h3 id="一个木马程序的例子" tabindex="-1"><a class="header-anchor" href="#一个木马程序的例子" aria-hidden="true">#</a> 一个木马程序的例子</h3><p><img src="/CS526/assets/f08_the-977c6ad5.png" alt="the"></p><ul><li><p>初始状态下，授权主体B不能够阅读文件F。</p></li><li><p>授权主体A能够执行含有木马的程序，这个程序将文件F复制到文件G。</p></li></ul><p><img src="/CS526/assets/f09_the2-c246ca62.png" alt="the2"></p><ul><li>在此时，授权主体B可以阅读被复制到G的文件F的内容。</li></ul><h3 id="有漏洞的软件可能成为木马程序" tabindex="-1"><a class="header-anchor" href="#有漏洞的软件可能成为木马程序" aria-hidden="true">#</a> 有漏洞的软件可能成为木马程序</h3><ul><li>当有漏洞的软件被利用时，它会执行攻击者的代码/意图，同时使用启动它的用户的权限。</li><li>这意味着仅使用自主访问控制（DAC）的计算机无法被信任用于处理不同级别的机密信息。 <ul><li>强制访问控制（MAC）是为解决这个问题而开发的</li><li>我们将在下一个章节中介绍MAC。</li></ul></li></ul><details class="custom-container details"><p><strong>Q</strong>: 你能为我大致解释一下“强制性访问控制是如何解决这个问题”吗？</p><p><strong>A</strong>(<em>AI生成</em>)：</p><p>强制访问控制（Mandatory Access Control，MAC）是为了解决自主访问控制（Discretionary Access Control，DAC）系统的限制和漏洞，特别是针对DAC实施不当导致的意外信息流问题。</p><p>在DAC系统中，对象的所有者或创建者有权自行设置决定谁能访问和修改该对象的权限。然而，当DAC在没有适当限制或限定的情况下实施时，可能会导致意外的信息流。这意味着信息可能从一个可以读取的对象流向另一个可以被主体写入的对象，即使这不是预期或授权的。</p><p>MAC的设计旨在通过引入更加集中和严格的访问控制机制来解决这个问题。在MAC系统中，访问控制策略不仅仅依赖于对象所有者的自行决定。相反，可信任的权威，如操作系统或安全管理员，根据预定义的规则和标签来定义和执行访问控制策略。</p><p>这些策略通常基于对象的分类或敏感性以及主体的准入级别。根据这些标签和策略的评估，决定是否授予或拒绝访问权限，以确保信息流受到控制和授权。</p><p>通过实施MAC，组织可以强制执行更严格的访问控制措施，防止DAC系统中可能出现的意外信息流。MAC提供了对访问权限的更加精细和集中的控制，降低了因DAC实施不当而带来的风险。</p><p>总之，MAC通过引入集中的访问控制机制来解决DAC系统中的意外信息流问题，该机制强制执行基于对象分类和主体准入级别的预定义策略和规则。这有助于确保对信息访问的适当控制和授权，以减轻未经授权的信息流所带来的风险。</p></details><h3 id="dac的弱点是由于主体与权限持有者之间存在差距所致" tabindex="-1"><a class="header-anchor" href="#dac的弱点是由于主体与权限持有者之间存在差距所致" aria-hidden="true">#</a> DAC的弱点是由于主体与权限持有者之间存在差距所致</h3><ul><li>请求：一个<strong>主体</strong>希望执行某个操作 <ul><li>例如，在操作系统中的进程</li></ul></li><li>策略：每个<strong>授权主体</strong>都有一组权限 <ul><li>例如，在操作系统中的用户帐户</li></ul></li><li>在主体和授权主体之间填补差距是具有挑战性的 <ul><li>使主体与授权主体之间产生关联</li></ul></li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>我们总结以下上述分析。 一方面，在请求中，主体希望执行某个操作。 另一方面，在策略中，权限是授予授权主体的。 为了决定是否允许请求，我们必须填补请求中的主体与策略中的授权主体之间的差距。具体而言，我们需要将主体与授权主体相关联，以便根据策略确定主体是否具有执行操作的权限。</p></div><h2 id="unix-dac-revisited-1" tabindex="-1"><a class="header-anchor" href="#unix-dac-revisited-1" aria-hidden="true">#</a> Unix DAC Revisited (1)</h2><p><img src="/CS526/assets/f10_udacr1-00b2ae2d.png" alt="udacr1"></p><ul><li>When the Goodie process issues a request, what principal(s) is/are responsible for the request?</li><li>Under what assumption, it is correct to say that User A is responsible for the request?</li><li><strong>Assumption: Programs are benign, i.e., they only do what they are told to do.</strong></li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Both User A and User B</p></div><h2 id="对unix系统中dac的重新审视-1" tabindex="-1"><a class="header-anchor" href="#对unix系统中dac的重新审视-1" aria-hidden="true">#</a> 对Unix系统中DAC的重新审视(1)</h2><p><img src="/CS526/assets/f10_udacr1-00b2ae2d.png" alt="udacr1"></p><ul><li>当Goodie进程发出一个请求时，什么主体对该请求负责？</li><li>在什么假设下，说用户A对该请求负责是正确的？</li><li><strong>假设： 程序是良性的，也就是说，它们只会执行被告知要做的事情</strong>。</li></ul><p>::tip 用户A和用户B都是 :::</p><h2 id="对unix系统中dac的重新审视-2" tabindex="-1"><a class="header-anchor" href="#对unix系统中dac的重新审视-2" aria-hidden="true">#</a> 对Unix系统中DAC的重新审视(2)</h2><p><img src="/CS526/assets/f11_udacr2-f1c8069d.png" alt="udacr2"></p><ul><li>当AcroBat进程（在读取文件后）发出一个请求时，哪个（些）授权主体对该请求负责？</li><li>在什么假设下，说用户A对该请求负责是正确的？</li><li><strong>假设： 程序是正确的，也就是说，它们能正确地处理输入。</strong></li></ul><h2 id="为什么dac是易受攻击的" tabindex="-1"><a class="header-anchor" href="#为什么dac是易受攻击的" aria-hidden="true">#</a> 为什么DAC是易受攻击的？</h2><ul><li>DAC包含隐含的假设 <ul><li>软件是良性的，即按照预期的行为</li><li>软件是正确的，即没有错误</li></ul></li><li>而现实情况是： <ul><li>恶意软件很常见</li><li>软件容易受到攻击</li></ul></li><li>问题并不是由政策规范的自由裁量性引起的 <ul><li>指的是所有者可以为文件设置策略</li></ul></li></ul><details class="custom-container details"><p>“问题不是由政策规范的自由裁量性引起的！”指的是DAC的漏洞并不是因为所有者可以自由设置文件或资源的策略而固有的。DAC的自由裁量性质，即所有者可以决定访问权和权限，并不是系统中的弱点和漏洞的根本原因。</p><p>DAC的问题在于其他方面，例如对软件行为和正确性的隐含假设，恶意软件和软件漏洞的存在，以及在捕获进程的起源方面的局限性。它表明，简单地改变政策规范的自由裁量性质（即所有者可以设置政策），并不能解决DAC的根本弱点。</p><p>从本质上讲，DAC的自由裁量性质本身并不是问题所在。相反，是对某些假设的依赖，恶意软件的存在，以及缺乏全面的执行机制，导致了DAC的脆弱性。</p></details><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>根据以上分析，识别发起者为程序调用者，DAC实际上做出了两个隐含的假设。 首先，它假设所有软件都是良性的。所有软件都按照预期的功能工作，不执行任何恶意活动。 其次，它假设软件是正确的。特别是，输入提供者不能将恶意代码注入程序中。 然而，这些假设在现实世界中是不成立的。事实是，恶意软件很常见，而且软件往往容易受到攻击。</p></div><ul><li>执行机制中的更深层次原因 <ul><li>一个<strong>单独的调用者</strong>不足以捕捉一个进程的来源</li></ul></li><li>当程序是木马程序时 <ul><li>应该将<strong>程序提供者</strong>视为请求的负责方</li></ul></li><li>当程序容易受到攻击时 <ul><li>它可能被输入提供者利用</li><li>请求可能由输入提供者注入的代码发出</li></ul></li><li>解决方案：将输入提供者作为主体之一</li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>导致DAC容易受到攻击的根本原因是，一个单独的调用者无法捕捉一个进程的来源。 当程序是木马程序时，应该将程序提供者视为发出请求的责任方。 当程序存在漏洞时，它可能会受到输入提供者的攻击。请求可能由输入提供者注入的代码发出。 要解决DAC中的弱点，我们需要在识别来源时考虑程序提供者和输入提供者。</p><details class="custom-container details"><p>让我们考虑一个例子来说明在识别一个进程的起源时需要考虑程序提供者和输入提供者。</p><p>假设我们有一个文件共享应用程序，用户可以上传和下载文件。每个用户都有他们自己的文件集，他们可以对他们的文件设置权限，以控制谁可以访问它们。在这种情况下，用户是所有者，可以为他们的文件设置策略（这是符合DAC的）。</p><p>现在，让我们考虑以下几种情况：</p><p>木马程序： 用户A上传了一个程序到文件共享应用程序。用户A不知道该程序含有恶意代码，在被其他用户执行时，会执行未经授权的操作。当另一个用户，即用户B，下载并执行该程序时，恶意代码开始执行并非用户B意图的行动。在这种情况下，程序提供者（用户A）应该对程序发出的请求负责。单纯的DAC可能不足以将这些行动归于正确的来源。</p><p>易受攻击的程序： 用户A上传了一个有漏洞的程序，例如缓冲区溢出。当另一个用户，即用户B，与该程序互动并提供特定的输入，他们可以利用该漏洞并将恶意代码注入到程序的执行中。在这种情况下，输入提供者（用户B）成为识别请求来源的一个重要因素。单纯的DAC可能无法捕捉到注入代码的来源。</p><p>在这两种情况下，仅靠DAC是不足以将请求或行动归于正确的来源的。为了解决这些漏洞，建议的解决方案是将输入提供者作为授权主体，并在识别进程的来源时考虑程序提供者。通过扩大授权主体的范围，包括那些提供输入的人（输入提供者）和那些提供程序的人（程序提供者），就有可能更准确地分配责任并将行动归于适当的来源。</p></details></div></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 55586323+Klee1453@users.noreply.github.com">Klee1453</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/CS526/assets/app-eef777f9.js" defer></script>
  </body>
</html>
